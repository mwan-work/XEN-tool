<!DOCTYPE html>
<html>
<head>
  <title>XML Tidy Tool</title>
  <style>
    #xmlInput {
      width: 100%;
      height: 200px;
    }
    #tidyButton {
      margin-top: 10px;
    }
	#outputArea {
    background-color: black;
    color: white; /* Set the text color to white */
    font-size: 16px; /* Set the font size */
    font-weight: bold; /* Set the font weight to bold */
	overflow: auto;
        width: 100%;
      height: 300px;
  }

  /* Styles for the outputXPath */
  #outputXPath {
    font-size: 18px; /* Set the font size */
    font-weight: bold; /* Set the font weight to bold */
    /* Add any other styles you need for the outputXPath */
  }
  
  #validationMessage {
      color: red; /* Set color for validation message */
    }
  </style>
</head>
<body>
  <textarea id="xmlInput" placeholder="Enter XML code here" oninput="validateXML()"></textarea>
  <div id="validationMessage"></div> <!-- Display validation message here -->
  <button id="singleButton">TIDY and EXTRACT</button>
  <button id="tidyButton" >Tidy XML</button>
  <button onclick="extractXPath()" ed>Extract XPath</button>
  <button id="highlightButton">Highlight XML</button>
  <div id="outputArea"></div>
  <div id="outputXPath"></div>

  <script>
    function performActions() {
    tidyXML();
	highlightXML();
    extractXPath();
  }

  const singleButton = document.getElementById('singleButton');
  singleButton.addEventListener('click', performActions);
  
  
    document.getElementById('tidyButton').addEventListener('click', function() {
      tidyXML();
    });

 function tidyXML() {
  const input = document.getElementById('xmlInput');
  let xmlString = input.value;

  // Escape special characters in XML
  xmlString = escapeSpecialCharacters(xmlString);

  const formattedXML = formatXML(xmlString);
  input.value = formattedXML;
}

function escapeSpecialCharacters(xmlString) {
  // Replace '&' with '&amp;'
  return xmlString.replace(/&/g, '&amp;');
  return inputString.replace(/(\r\n|\n|\r)/gm, '');
}

function formatXML(xmlString) {
  const parser = new DOMParser();
  const xmlDoc = parser.parseFromString(xmlString, 'application/xml');
  const rootElement = xmlDoc.documentElement;
  const formatted = formatElement(rootElement, 0);
  return formatted;
}


    function formatElement(element, level) {
      const tab = '  '; // Two spaces for each level of indentation
      const newline = '\n';
      let formatted = '';

      if (element.nodeType === Node.ELEMENT_NODE) {
        formatted += newline + tab.repeat(level);
      }

      formatted += '<' + element.tagName;

      const attributes = element.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attribute = attributes[i];
        formatted += ' ' + attribute.name + '="' + attribute.value + '"';
      }

      if (element.childElementCount > 0 || element.textContent.trim() !== '') {
        formatted += '>';

        const children = element.childNodes;
        for (let i = 0; i < children.length; i++) {
          const child = children[i];
          if (child.nodeType === Node.ELEMENT_NODE) {
            formatted += formatElement(child, level + 1);
          } else if (child.nodeType === Node.TEXT_NODE && child.nodeValue.trim() !== '') {
            formatted += child.nodeValue.trim();
          }
        }

        formatted += newline + tab.repeat(level);
        formatted += '</' + element.tagName + '>';
      } else {
        formatted += '></' + element.tagName + '>';
      }

      return formatted;
    }
		
		 function extractXPath() {
  const outputAreaContent = document.getElementById('outputArea').innerText;
  const xmlDoc = new DOMParser().parseFromString(outputAreaContent, 'text/xml');
      const nodes = xmlDoc.evaluate('//*', xmlDoc, null, XPathResult.ANY_TYPE, null);
      
      let xpathResult = '';
      let node = nodes.iterateNext();
      while (node) {
        const xpath = getXPath(node);
        xpathResult += `<div class="xpathElement">${xpath}</div>`;
        node = nodes.iterateNext();
      }
      
      document.getElementById('outputXPath').innerHTML = xpathResult.trim();
    }
	
	
	   function getXPath(node) {
      if (node.nodeType === Node.ELEMENT_NODE) {
        const element = node;
        const sameTagSiblings = Array.from(element.parentNode.childNodes).filter(e => e.tagName === element.tagName);
        const index = sameTagSiblings.indexOf(element) + 1;
        return getXPath(element.parentNode) + '/' + element.tagName.toLowerCase() + '[' + index + ']';
      }
      return '';
    }

    document.getElementById('outputXPath').addEventListener('click', function(event) {
      if (event.target.classList.contains('xpathElement')) {
        const xpath = event.target.textContent;
        const xmlInput = document.getElementById('xmlInput').value;
        const xmlDoc = new DOMParser().parseFromString(xmlInput, 'text/xml');
        const element = xmlDoc.evaluate(xpath, xmlDoc, null, XPathResult.FIRST_ORDERED_NODE_TYPE, null).singleNodeValue;

        if (element) {
          const range = document.createRange();
          range.selectNodeContents(element);
          const selection = window.getSelection();
          selection.removeAllRanges();
          selection.addRange(range);
        }
      }
    });
	
function highlightXML() {
  const xmlInput = document.getElementById('xmlInput');
  const outputArea = document.getElementById('outputArea');

  const xmlCode = xmlInput.value;

  // Escape HTML entities to display correctly
  const encodedXML = xmlCode.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');

  // Match XML tags using regular expression and apply consistent colors
  const tagColors = {};
  const tagCounts = {};

  let xpath = '';
  let highlightedXML = '<pre>'; // Start with <pre> tag to preserve formatting

  // Define regular expressions to match opening and closing tags with attributes
  const tagRegex = /&lt;(\/?\w+)([^&]*?)&gt;/g;

  // Split XML by line breaks to preserve them
  const lines = encodedXML.split('\n');

  lines.forEach((line, index) => {
    const leadingSpaces = line.match(/^\s*/)[0]; // Capture leading spaces
    const lineWithoutSpaces = line.trim(); // Trim leading/trailing spaces

    let lineWithTags = lineWithoutSpaces.replace(tagRegex, match => {
      const tagContent = match.replace(/&lt;|&gt;/g, ''); // Remove HTML encoding
      const isClosingTag = tagContent.startsWith('/');

      const tagName = tagContent.split(' ')[0].replace('/', ''); // Extract tag name

      if (!isClosingTag) {
        if (!tagCounts[xpath]) {
          tagCounts[xpath] = {};
        }

        if (!tagCounts[xpath][tagName]) {
          tagCounts[xpath][tagName] = 1;
        } else {
          tagCounts[xpath][tagName]++;
        }

        let color;
        if (!tagColors[tagName]) {
          color = '#' + Math.floor(Math.random() * 16777215).toString(16);
          tagColors[tagName] = color;
        } else {
          color = tagColors[tagName];
        }

        const tagCount = tagCounts[xpath][tagName];
        xpath += `/${tagName}[${tagCount}]`;

        return `<span data-tag="${tagName}" style="color: ${color}">${match}</span>`;
      } else {
        const openingTagName = tagName;
        const closingTagName = openingTagName;

        let color;
        if (tagColors[openingTagName]) {
          color = tagColors[openingTagName];
        } else {
          color = '#' + Math.floor(Math.random() * 16777215).toString(16);
          tagColors[openingTagName] = color;
        }

        xpath = xpath.substring(0, xpath.lastIndexOf(`/${closingTagName}`));

        return `<span data-tag="${closingTagName}" style="color: ${color}">${match}</span>`;
      }
    });

    highlightedXML += `${leadingSpaces}${lineWithTags}`;

    if (index < lines.length - 1) {
      highlightedXML += '\n'; // Append newline character for line breaks, except for the last line
    }
  });

  highlightedXML += '</pre>'; // Close <pre> tag

  // Replace the HTML of outputArea with the modified XML content
  outputArea.innerHTML = highlightedXML;
}






    const highlightButton = document.getElementById('highlightButton');
    highlightButton.addEventListener('click', highlightXML);
	
	  function validateXML() {
      const input = document.getElementById('xmlInput').value;
      const parser = new DOMParser();
      const xmlDoc = parser.parseFromString(input, 'application/xml');

      const validationMessage = document.getElementById('validationMessage');
      const buttons = document.querySelectorAll('button');

      // Check if XML has a root element
      if (xmlDoc.documentElement === null) {
        validationMessage.innerText = 'XML is missing a root element';
        
        return;
      }

      // Check for missing end tags
      const parserErrors = xmlDoc.getElementsByTagName('parsererror');
      if (parserErrors.length > 0) {
        validationMessage.innerText = 'XML has missing or incorrect end tags';
        
        return;
      }

      // If all checks pass, display success message and enable buttons
      validationMessage.innerText = 'XML is valid';
      
    }

  
  </script>
</body>
</html>
