<!DOCTYPE html>
<html>
<head>
  <title>XML Tool</title>
  <style>

.container {
  display: flex;

}
.line {
    /* Your existing styles for each row */
    /* For example: */
  
  
    /* Any other styles for each row */
}

.line.highlighted {
    background-color: darkgrey;
    color: white;
    /* Any other styles for the highlighted row */
}

    #topbanner {
      width: 100%;
      height: 80px;
	  background-color: purple;
	  border: 1px solid purple;
	  color: white;
	  font-weight: bold;
    }

    #xmlInput {
      width: 50%;
      height: 200px;
	  resize: vertical;
    }
    #tidyButton {
      margin-top: 10px;
    }
	#outputArea {
    background-color: black;
    color: white; /* Set the text color to white */
    font-size: 16px; /* Set the font size */
    font-weight: bold; /* Set the font weight to bold */
	overflow: auto;
        width: 100%;
      height: 400px;
	  text-shadow: 0px 1px 0px rgba(255, 255, 255, 0.2);
  }

  /* Styles for the outputXPath */
  #outputXPath {
  	overflow: auto;
        width: 100%;
      height: 400px;
    font-size: 18px; /* Set the font size */
    font-weight: bold; /* Set the font weight to bold */
	border: 1px solid black; 
    /* Add any other styles you need for the outputXPath */
  }
  
  #validationMessage {
      color: red; /* Set color for validation message */
    }
  </style>
</head>
<body>
<div id="topbanner"><font size=12>XML TOOL</font></div>
<br>
<b>XML Input:</b><br>
  <textarea id="xmlInput" placeholder="Enter XML code here" oninput="validateXML()"></textarea>
  <div id="validationMessage">XML Input Check:</div> <!-- Display validation message here -->
  <button id="singleButton">Tidy XML and Extract XPATH</button>
  <button onclick="tidyXML()">TIDY</button>
  <button onclick="handleReplace()">Replace Namespaces</button>
  <button onclick="generateExampleXML()">Insert Example XML</button>
<button onclick="generateRandomXML()">Generate Random XML</button>

  <button onclick="clearXMLInput()">Clear XML Input</button>




<table style="width:100%">
<tr><td style="width:50%"><b>Tidy XML Output:</b></td><td><b>Xpath Output:</b></td style="width:50%"></tr>
</table>
  
<div class="container">
    
    
      <div id="outputArea"></div>
    
    
      
      <div id="outputXPath"></div>
    
  </div>


   <script>
   
   
function clearXMLInput() {
  document.getElementById('xmlInput').value = ''; // Clears the content of the XML input
}

function generateRandomXML() {
  const maxLevels = 3; // Maximum levels of nesting
  const lineCount = 30; // Number of lines in the random XML
  let randomXML = '<?xml version="1.0" encoding="UTF-8"?>\n<root>'; // Start with root element
  
  for (let i = 0; i < lineCount; i++) {
    randomXML += `\n  <element_${i + 1}>`;
    
    // Generate a random number of child elements
    const childCount = Math.floor(Math.random() * maxLevels) + 1;
    
    for (let j = 0; j < childCount; j++) {
      randomXML += `\n    <child_${j + 1}>Random Text ${Math.floor(Math.random() * 100)}</child_${j + 1}>`;
    }
    
    randomXML += `\n  </element_${i + 1}>`;
  }
  
  randomXML += '\n</root>'; // Close the root element
  
  document.getElementById('xmlInput').value = randomXML; // Set the random XML content into the XML input
}

function performActions() {
  


  handleReplace();
    tidyXML();
	handleRestore();
    shiftContentUp();
    highlightXML();
	
    
    extractXPath();
    
  
}


  const singleButton = document.getElementById('singleButton');
  singleButton.addEventListener('click', performActions);
  
  


 function tidyXML() {
  const input = document.getElementById('xmlInput');
  let xmlString = input.value;

  // Escape special characters in XML
  xmlString = escapeSpecialCharacters(xmlString);

  const formattedXML = formatXML(xmlString);
  input.value = formattedXML;
}


function replaceNamespace(xmlInput) {
  const replacedInput = xmlInput.replace(/<([^>]+):/g, '<$1UNIQ-')
    .replace(/<\/([^>]+):/g, '</$1UNIQ-');

  return replacedInput;
}



function handleReplace() {
  const inputElement = document.getElementById('xmlInput');
  const xmlContent = inputElement.value;

  const modifiedXML = replaceNamespace(xmlContent);
  console.log(modifiedXML); // You can log it or use it as needed

  // For demonstration purposes, update the textarea with the modified content
  inputElement.value = modifiedXML;
}

function restoreNamespace(xmlInput) {
  const restoredInput = xmlInput.replace(/<([^>]+)UNIQ-/g, '<$1:')
    .replace(/<\/([^>]+)UNIQ-/g, '</$1');

  return restoredInput;
}



function handleRestore() {
  const inputElement = document.getElementById('xmlInput');
  const xmlContent = inputElement.value;

  const modifiedXML = restoreNamespace(xmlContent);
  console.log(modifiedXML); 

  // For demonstration purposes, update the textarea with the modified content
  inputElement.value = modifiedXML;
}

function escapeSpecialCharacters(xmlString) {
  // Replace '&' with '&amp;'
  return xmlString.replace(/&/g, '&amp;');
  return inputString.replace(/(\r\n|\n|\r)/gm, '');
}

function formatXML(xmlString) {
  const parser = new DOMParser();
  const xmlDoc = parser.parseFromString(xmlString, 'application/xml');
  const rootElement = xmlDoc.documentElement;
  const formatted = formatElement(rootElement, 0);
  return formatted;
}


    function formatElement(element, level) {
      const tab = '   '; // Two spaces for each level of indentation
      const newline = '\n';
      let formatted = '';

      if (element.nodeType === Node.ELEMENT_NODE) {
        formatted += newline + tab.repeat(level);
      }

      formatted += '<' + element.tagName;

      const attributes = element.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attribute = attributes[i];
        formatted += ' ' + attribute.name + '="' + attribute.value + '"';
      }

      if (element.childElementCount > 0 || element.textContent.trim() !== '') {
        formatted += '>';

        const children = element.childNodes;
        for (let i = 0; i < children.length; i++) {
          const child = children[i];
          if (child.nodeType === Node.ELEMENT_NODE) {
            formatted += formatElement(child, level + 1);
          } else if (child.nodeType === Node.TEXT_NODE && child.nodeValue.trim() !== '') {
            formatted += child.nodeValue.trim();
          }
        }

        formatted += newline + tab.repeat(level);
        formatted += '</' + element.tagName + '>';
      } else {
        formatted += '></' + element.tagName + '>';
      }

      return formatted;
    }
		
function extractXPath() {
  const outputArea = document.getElementById('outputArea');
  const lines = outputArea.innerText.split('\n');

  let xpathResult = '';
  let openTagsStack = [];

  for (let i = 0; i < lines.length; i++) {
    const line = lines[i].trim();
    const lineNumber = i + 1;

    const openTags = line.match(/<[^/][^>]*>/g) || [];
    const closeTags = line.match(/<\/.*?>/g) || [];

    openTags.forEach((openTag) => {
      const tagName = openTag.match(/<([^>\s]+)[^>]*>/)[1].toLowerCase();
      openTagsStack.push(tagName);

      const xpathTags = openTagsStack.join('/');
      xpathResult += `[LINE ${String(lineNumber).padStart(3, '0')}] /${xpathTags}\n`;
    });

    closeTags.forEach(() => {
      openTagsStack.pop();
    });
  }

  // Remove the numbers at the end of the XPath
  xpathResult = xpathResult.replace(/\[\d+\]/g, '');

  document.getElementById('outputXPath').innerText = xpathResult.trim();
}



function getXPath(node) {
  if (node.nodeType === Node.ELEMENT_NODE) {
    const element = node;
    const sameTagSiblings = Array.from(element.parentNode.childNodes)
      .filter(e => e.tagName === element.tagName && e.nodeType === Node.ELEMENT_NODE);

    const index = sameTagSiblings.indexOf(element) + 1;

    let xpath = '/' + element.tagName.toLowerCase() + '[' + index + ']';

    let parentNode = element.parentNode;
    while (parentNode !== null && parentNode.nodeType === Node.ELEMENT_NODE) {
      const sameTagParentSiblings = Array.from(parentNode.parentNode.childNodes)
        .filter(e => e.tagName === parentNode.tagName && e.nodeType === Node.ELEMENT_NODE);
      
      const parentIndex = sameTagParentSiblings.indexOf(parentNode) + 1;
      xpath = '/' + parentNode.tagName.toLowerCase() + '[' + parentIndex + ']' + xpath;
      
      parentNode = parentNode.parentNode;
    }

    return xpath;
  }
  return '';
}

function highlightXML() {
  const xmlInput = document.getElementById('xmlInput');
  const outputArea = document.getElementById('outputArea');

  const xmlCode = xmlInput.value;

  // Escape HTML entities to display correctly
  const encodedXML = xmlCode.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');

  // Match XML tags using regular expression and apply consistent colors
  const tagColors = {};
  const tagCounts = {};

  let xpath = '';
  let lineNumber = 1;
  let highlightedXML = '<pre>'; // Start with <pre> tag to preserve formatting

  const lines = encodedXML.split('\n');

  lines.forEach((line) => {
    const leadingSpaces = line.match(/^\s*/)[0]; // Capture leading spaces
    const lineWithoutSpaces = line.trim(); // Trim leading/trailing spaces

    let lineWithTags = lineWithoutSpaces.replace(/&lt;(\/?\w+)([^&]*?)&gt;/g, match => {
      const tagContent = match.replace(/&lt;|&gt;/g, ''); // Remove HTML encoding
      const isClosingTag = tagContent.startsWith('/');

      const tagName = tagContent.split(' ')[0].replace('/', ''); // Extract tag name

      if (!isClosingTag) {
        if (!tagCounts[xpath]) {
          tagCounts[xpath] = {};
        }

        if (!tagCounts[xpath][tagName]) {
          tagCounts[xpath][tagName] = 1;
        } else {
          tagCounts[xpath][tagName]++;
        }

        let color;
        if (!tagColors[tagName]) {
          color = '#' + Math.floor(Math.random() * 16777215).toString(16);
          tagColors[tagName] = color;
        } else {
          color = tagColors[tagName];
        }

        const tagCount = tagCounts[xpath][tagName];
        xpath += `/${tagName}[${tagCount}]`;

        return `<span class="tag" data-tag="${tagName}" style="color: ${color}">${match}</span>`;
      } else {
        const openingTagName = tagName;
        const closingTagName = openingTagName;

        let color;
        if (tagColors[openingTagName]) {
          color = tagColors[openingTagName];
        } else {
          color = '#' + Math.floor(Math.random() * 16777215).toString(16);
          tagColors[openingTagName] = color;
        }

        xpath = xpath.substring(0, xpath.lastIndexOf(`/${closingTagName}`));

        return `<span class="tag" data-tag="${closingTagName}" style="color: ${color}">${match}</span>`;
      }
    });

    const lineContent = `<div class="line"><span class="lineNumber">${String(lineNumber).padStart(3, '0')}</span>${leadingSpaces}${lineWithTags}</div>`; // Adjusted lineContent with line numbers at the beginning

    highlightedXML += lineContent;

    lineNumber++;
  });

  highlightedXML += '</pre>'; // Close <pre> tag

  outputArea.innerHTML = highlightedXML; // Update the outputArea with the modified content

  // Add event listeners for row highlighting
const clickableElements = outputArea.querySelectorAll('.line');
clickableElements.forEach(element => {
  element.addEventListener('click', function(event) {
    const row = event.target.closest('.line');
    
    // Check if the clicked row is already highlighted
    const isHighlighted = row.classList.contains('highlighted');
    
    // Remove highlight from all rows
    const rows = outputArea.querySelectorAll('.line.highlighted');
    rows.forEach(row => {
      row.classList.remove('highlighted');
    });

    // Toggle highlight on the clicked row
    if (!isHighlighted) {
      row.classList.add('highlighted');
    }
  });
});


}





	
	  function validateXML() {
      const input = document.getElementById('xmlInput').value;
      const parser = new DOMParser();
      const xmlDoc = parser.parseFromString(input, 'application/xml');

      const validationMessage = document.getElementById('validationMessage');
      const buttons = document.querySelectorAll('button');

    

      // Check for missing end tags
      const parserErrors = xmlDoc.getElementsByTagName('parsererror');
      if (parserErrors.length > 0) {
        validationMessage.innerText = 'XML Input Check: Missing or incorrect end tags. Errors may occur on output.';
        
        return;
      }

      // If all checks pass, display success message and enable buttons
      validationMessage.innerText = 'XML Input Check: Good';
      
    }

  function removeLineNumber() {
  const outputArea = document.getElementById('outputArea');
  const firstLine = outputArea.querySelector('pre').firstChild;

  if (firstLine.nodeType === Node.ELEMENT_NODE && firstLine.classList.contains('lineNumber')) {
    outputArea.querySelector('pre').removeChild(firstLine);
  }
}





function shiftContentUp() {
  const xmlInput = document.getElementById('xmlInput');
  const currentValue = xmlInput.value;

  // Split the input by lines and remove the first line
  const lines = currentValue.split('\n');
  if (lines.length > 1) {
    lines.shift(); // Remove the first line
    xmlInput.value = lines.join('\n');
  } else {
    xmlInput.value = ''; // Clear the content if there's only one line
  }
}



  </script>
</body>
</html>
